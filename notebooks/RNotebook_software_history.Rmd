---
title: "On the Relation Between the History of Changes and Bugs"
output:
  html_notebook: default
  html_document:
    code_folding: hide
---


```{r message=FALSE}
suppressWarnings(library(dplyr))
suppressWarnings(library(stringr))
suppressWarnings(library(sqldf))
suppressWarnings(library(ggplot2))
suppressWarnings(library(beanplot))
suppressWarnings(library(vioplot))
suppressWarnings(library(ggpubr))
suppressWarnings(library(qcc))

methods <-
  read.csv(
    "~/R/analysis/methods/allMethodsall.csv",
    stringsAsFactors = FALSE
  )

getTypeMethod <- function (x){
  
  splitRef <- strsplit(x, "\\.") #divide o nome do metodo pelo ponto
  #splitRef
  
  for(d in splitRef){ 
    r <- sub("[(].*", "", d) #remove os paramentros do metodo
  }
  #r #Nessa var tem os valores separados, só fazer um if e verificar se os dois ultimos são iguais, ai cai no caso do construtor 
  
  nomeMetodo <- sub(".*[.]", "", x) #seleciona o nome do metodo
  nomeMetodoSemParam <- sub("[(].*", "", nomeMetodo) #remove os parametros
  #nomeMetodoSemParam #só verificar se é igual a toString 
  
  getOuSet <- substring(nomeMetodoSemParam, 1, 3) #seleciona os 3 primeiros elementos do metodo
  #getOuSet # só verificar se é um get ou set
  
  if (getOuSet == "set" || getOuSet == "get"){
    return ("Getters/Setters")
    
  } else if (nomeMetodo == "toString"){
    return ("toString")
    
  } else if (r[length(r)] == r[length(r)-1]){
    return ("Constructor")
    
  } else {
    return ("Normal")
  }
  
}

# implementing the function:
ggpareto <- function(x, title, labelx) {
  
  #title <- deparse(substitute(x))
  
  x <- data.frame(modality = na.omit(x))
  
  Df <- x %>% group_by(modality) %>% summarise(frequency=n()) %>% 
    arrange(desc(frequency))
  
  Df$modality <- ordered(Df$modality, levels = unlist(Df$modality, use.names = F))
  
  Df <- Df %>% mutate(modality_int = as.integer(modality), 
                      cumfreq = cumsum(frequency), cumperc = cumfreq/nrow(x) * 100)
  nr <- nrow(Df)
  N <- sum(Df$frequency)
  
  Df_ticks <- data.frame(xtick0 = rep(nr +.55, 11), xtick1 = rep(nr +.59, 11), 
                         ytick = seq(0, N, N/10))
  
  y2 <- c("  0%", " 10%", " 20%", " 30%", " 40%", " 50%", " 60%", " 70%", " 80%", " 90%", "100%")
  
  g <- ggplot(Df, aes(x=modality, y=frequency)) + 
    geom_bar(stat="identity", aes(fill = modality_int)) +
    geom_line(aes(x=modality_int, y = cumfreq, color = modality_int)) +
    geom_point(aes(x=modality_int, y = cumfreq, color = modality_int), pch = 19) +
    scale_y_continuous(breaks=seq(0, N, N/10), limits=c(-.02 * N, N * 1.02)) + 
    scale_x_discrete(breaks = Df$modality) +
    guides(fill = FALSE, color = FALSE) + 
    annotate("rect", xmin = nr + .55, xmax = nr + 1, 
             ymin = -.02 * N, ymax = N * 1.02, fill = "white") +
    annotate("text", x = nr + .8, y = seq(0, N, N/10), label = y2, size = 3.5) +
    geom_segment(x = nr + .55, xend = nr + .55, y = -.02 * N, yend = N * 1.02, color = "grey50") +
    geom_segment(data = Df_ticks, aes(x = xtick0, y = ytick, xend = xtick1, yend = ytick)) +
    labs(title = paste0("Pareto Chart of ", title), y = "Frequency of Commits", x = labelx) +
    theme_bw() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
  
  print(g)
  
  #return(list(graph = g, Df = Df[, c(3, 1, 2, 4, 5)]))
  return (graph = g)
}

methods$typeMethod <- sapply(methods$MethodName, getTypeMethod) 

```


####RQ1: How often do changes and bugs occurin the history of methods?
Aprofundar as analises da RQ1 e demais com o objetivo de descobrir que tipos de metodos estão ocorrendo com poucos commits (1~3) e muitos commits (~10) dentre os projetos analisados. Analisar se os metodos com poucos commits são getters and setters. 

* Gráfico dos projetos Contendo a Quantidade commits x Tipos de Metodos
```{r}

#@TODO  Ver um Gráfico que Demonstre esses valores com a media/mediana dos commits
typeMethodsData <- summarise(group_by(methods, Project, typeMethod), Amount= sum(Count), MedianK = median(NtimeofCommits), MeanK = mean(NtimeofCommits))

#Amount
ggplot(typeMethodsData) +
  geom_bar(aes(x = Project, y = Amount, fill = typeMethod, group = typeMethod), position = "dodge", stat = "identity") +
  geom_text( aes(x = Project, y = Amount, label = round(Amount), group = typeMethod),  
             check_overlap = TRUE, position = position_dodge(width = 1), vjust = -0.5, size = 3) +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position= c(0.25, 0.95), legend.direction="horizontal", legend.title = element_blank(), 
        axis.title.x=element_blank(), legend.text=element_text(size=6), legend.background = element_rect(fill = "transparent", colour = NA)) +
  theme(panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(),
        plot.background = element_rect(fill = "transparent", colour = NA))



```

* Gráfico dos projetos Contendo a Mediana dos Commits x Tipos de Metodos
```{r}
#MedianK
ggplot(typeMethodsData) +
  geom_bar(aes(x = Project, y = MedianK, fill = typeMethod, group = typeMethod), position = "dodge", stat = "identity") +
  geom_text( aes(x = Project, y = MedianK, label = round(MedianK), group = typeMethod),  
             check_overlap = TRUE, position = position_dodge(width = 1), vjust = -0.5, size = 3) +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position= c(0.20, 0.95), legend.direction="horizontal", legend.title = element_blank(), 
        axis.title.x=element_blank(), legend.text=element_text(size=6), legend.background = element_rect(fill = "transparent", colour = NA)) +
  theme(panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(),
        plot.background = element_rect(fill = "transparent", colour = NA))
```


* Gráfico dos projetos Contendo a media commits x Tipos de Metodos
```{r}
#Mean
ggplot(typeMethodsData) +
  geom_bar(aes(x = Project, y = MeanK, fill = typeMethod, group = typeMethod), position = "dodge", stat = "identity") +
  geom_text( aes(x = Project, y = MeanK, label = round(MeanK), group = typeMethod),  
             check_overlap = TRUE, position = position_dodge(width = 1), vjust = -0.5, size = 3) +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position= c(0.20, 0.95), legend.direction="horizontal", legend.title = element_blank(), 
        axis.title.x=element_blank(), legend.text=element_text(size=6), legend.background = element_rect(fill = "transparent", colour = NA)) +
  theme(panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(),
        plot.background = element_rect(fill = "transparent", colour = NA))
```

* Boxplot dos Projetos

```{r}

#Boxplots por Projetos:
projects <- unique(methods$Project)

for (project in projects) {
  print(ggplot(filter(methods, Project == project), aes(x=typeMethod, y=NtimeofCommits)) + 
    geom_boxplot() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_x_discrete(name = project))
}
```

####Boxplots Gerais:
* Boxplot dos metodos Normais:
```{r}

ggplot(filter(methods, typeMethod == "Normal"), aes(x=Project, y=NtimeofCommits)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_x_discrete(name ="Normal")

```

* Boxplot dos metodos Construtores:
```{r}

ggplot(filter(methods, typeMethod == "Constructor"), aes(x=Project, y=NtimeofCommits)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_x_discrete(name ="Constructor")

```

* Boxplot dos metodos de Getters and Setters:
```{r}

ggplot(filter(methods, typeMethod == "Getters/Setters"), aes(x=Project, y=NtimeofCommits)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_x_discrete(name ="Getters/Setters")

```

* Violin Plot de todos os Projetos

```{r message=FALSE, warning=FALSE, echo=FALSE, comment= FALSE}


for (project in projects) {
  #Violin Plot
  with(filter(methods, Project == project), vioplot(NtimeofCommits[typeMethod == "Normal"],
                      NtimeofCommits[typeMethod == "Constructor"],
                      NtimeofCommits[typeMethod == "Getters/Setters"],
                      names = c("Normal", "Constructor", "Getters/Setters"),
                      col = "gray", colMed = rgb(115, 165, 214, maxColorValue = 255)))
  title(main = project, ylab = "Number of Commits", xlab = "TypeMethod")
}


```

* Boxplot da Media do numero de commits por projeto:

```{r}
ggplot(typeMethodsData, aes(x=Project, y=MeanK)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

Explicar as constraints como esse comportamento ocorre ao longo das constraints de maneira profunda, ou seja, explicar porque algumas constraints diminui pouco a % e algumas muito.

* **TODO** Nova tabela com o k=1:
```{r}
resultsC1C4<-
  sqldf(
    "SELECT Project, SUM(Count) as TotalTimeSeries, 
     SUM(CASE WHEN (P2 = 1) AND (P1 = 1) THEN 1 ELSE 0 end) as 'C1',
     SUM(CASE WHEN (P2 = 1) AND (P1 = 1) AND (P4 = 1) THEN 1 ELSE 0 end) as 'C1-C2',
     SUM(CASE WHEN (P2 = 1) AND (P1 = 1) AND (P4 = 1) AND (P5 = 1) THEN 1 ELSE 0 end) as 'C1-C2-C3',
     SUM(CASE WHEN (P2 = 1) AND (P1 = 1) AND (P4 = 1) AND (P3 = 1) THEN 1 ELSE 0 end) as 'C1-C2-C4',
     SUM(CASE WHEN (P2 = 1) AND (P1 = 1) AND (P3 = 1) AND (P4 = 1) AND (P5 = 1) THEN 1 ELSE 0 end) as 'C1-C2-C3-C4'
     FROM methods
     GROUP BY Project"
  )

#resultsC1C4
```

* Novo gráfico contendo os metodos com 1 e 2 commits :

```{r message=FALSE, warning=FALSE, echo=FALSE, comment= FALSE}
cbPalette <- c("#4D4D4D", "#5DA5DA", "#FAA43A", "#B276B2", "#F15854", "#009E73", "#F0E442", "#0072B2", "#999999", "#993300")

totalK <- as.data.frame(methods %>%
                          group_by(Project, NtimeofCommits) %>%
                          summarise(NumberK = sum(Count)))

sumTs <- as.data.frame(methods %>%
                         group_by(Project) %>%
                         summarise( totalTs = sum(Count)))

dataK <- inner_join(totalK, sumTs)		  
dataK[, "Perc"] <- round(dataK$NumberK/dataK$totalTs,2)

k1 <- ggplot(filter(dataK, NtimeofCommits <= 10, Project %in% projects[0:5])) +
  geom_bar(aes(x=NtimeofCommits,y=Perc,group=Project), position = "dodge", stat = "identity")+
  facet_grid(.~Project,scales="free") + 
  theme(legend.position= c(0.7, 0.95), legend.direction="horizontal", legend.title = element_blank(), 
        legend.text=element_text(size=5), legend.background = element_rect(fill = "transparent", colour = NA) ) +
  theme(axis.title.x=element_blank(), axis.title.y = element_blank()) +
  theme(panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(),
        plot.background = element_rect(fill = "transparent", colour = NA))


k2 <- ggplot(filter(dataK, NtimeofCommits <= 10, Project %in% projects[6:10])) +
  geom_bar(aes(x=NtimeofCommits,y=Perc,group=Project), position = "dodge", stat = "identity")+
  facet_grid(.~Project,scales="free") + 
  theme(legend.position= c(0.7, 0.95), legend.direction="horizontal", legend.title = element_blank(), 
        legend.text=element_text(size=5), legend.background = element_rect(fill = "transparent", colour = NA) ) +
  theme(axis.title.x=element_blank(), axis.title.y = element_blank()) +
  theme(panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(),
        plot.background = element_rect(fill = "transparent", colour = NA))


ggarrange(k1 , k2 , ncol = 1, nrow = 2)
```

**TODO:** As mudanças ocorrem mais no inicio do ciclo de vida do metodo ou no final? #Já em relação aos bugs, as mudanças ocorrem em antes ou depois dos pontos de inserção dos bugs? Fazer um calculo que para cada commit, trazer a quantidade de dias entre os mesmos, calcular o range total, #e contar quais commits estao no 1st~4st quartil.

```{r}
summary(methods$NtimeofCommits)
```


**TODO:** Outro ponto é Mostrar se as series são estacionárias ou não? Quais são as vantagens de achar uma grande quantidade de  #series estacionarias? Qual a diferença? existe alguma diferença em relação a variabilidade? tendência? etc. Como o foco não é mais com forecasting/predição. Tentar achar um motivo/vantagem na utilização de series estacionarias.




####RQ2: How close is the relationship betweenthe history of bugs and changes?


Explicar de formar mais intuitiva como seria satisfizar o método de Granger, ou seja, ter um numero menor de casos positivos de granger é bom ou ruim? Quais suas vantagens? Menor Overhead? **TODO:** Um ponto interessante seria trazer a cobertura de bugs do modelo. Nesse caso seria interessante trazer para cada método o ID dos bugs.

Fazer um comparativo entre os resultados de granger e regressão? Explicar o motivo de Granger ter resultados menos positivos? Será que os metodos tem mais commits que RL?  Nesse caso seria Fazer um boxplot/beanplot da diferença entre a tabela 3. analisando o histórico (anatomia dos metodos) entre as diferentes técnicas.

* Comparativo entre as tecnicas:

```{r warning=FALSE, echo=FALSE, comment= FALSE}

#Granger Positives
methodsGrangerPos <-
  read.csv(
    "~/R/analysis/methods/allMethodsGrangerPositives.csv",
    stringsAsFactors = FALSE)

methodsGrangerPos$Type <- "Granger"

#RL Positives
methodsReg <-
  read.csv(
    "~/R/analysis/methods/allMethodsRegression.csv",
    stringsAsFactors = FALSE)

methodsReg$Type <- "Linear"

methodsReg$pvalue <- NULL

allMethods <- rbind(methodsGrangerPos, methodsReg)

#Boxplots Geral:
ggplot(allMethods, aes(x=Type, y=NtimeofCommits)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_x_discrete(name ="Linear Reg x Granger")


#Violin Plot
with(allMethods, vioplot(NtimeofCommits[Type == "Granger"],
                      NtimeofCommits[Type == "Linear"],
                      names = c("Granger", "Linear"),
                      col = "gray", colMed = rgb(115, 165, 214, maxColorValue = 255)))
title(main = "Violin Plot", ylab = "Number of Commits", xlab = "Type")
```

#### RQ3: Which kind of changes are mostlyrelated to the bugs insertion?

Explicar os gráficas de maneira mais profunda. Ex: Explicar porque o elastich-search tem mais remoção de metricas do que adição. Explicar esse tipo de comportamento também em relação as metricas no demais gráficos. (Biel)

Plotar gráficos com ranking individuais utilizando o Gráfico de pareto em cima de cada uma das metricas; Dependendo dos resultados retirar os gráficos de grupos ou métricas devido a redundância apresentada no paper (Problema de agrupamento descrito pelo Leonardo)

* Gráfico de Pareto de Metricas Individuais

```{r}

#IndividualMetrics
indMetrics <- read.csv(file = "~/R/analysis/methods/dataMetricsGranger.csv", stringsAsFactors = FALSE)

# Transpose the data frame
#indMetrics <- t(indMetrics[,1:ncol(indMetrics)])
# Set the column headings from the first column in the original table
#colnames(indMetrics) <- indMetrics[1,] 
#pareto.chart(indMetrics, ylab = "Frequency", ylab2 = "Cumulative Percentage", xlab = "Presto",  
#cumperc = seq(0, 100, by = 25), main = "Pareto Chart",  plot = TRUE)

# Applying the function to the pareto function:
mylist <- ""

for (project in projects){
  df <- filter(indMetrics, Project == project)[,c(3,4)]
  i<-1
  for (x in 1:nrow(df)){
    for (y in 1:df$Changes[x]){
      mylist[i] <- df$Metric[x]
      i <- i + 1
    }
  }
  ggpareto(mylist, project, "Metrics")
}

```


* Gráfico de Pareto de Metricas Agrupadas:

```{r}
#Groups metrics
grpMetrics <- read.csv(file = "~/R/analysis/methods/dataGroupsGranger.csv", stringsAsFactors = FALSE)

# Applying the function to the pareto function:
for (project in projects){
  df <- filter(grpMetrics, Project == project)[,c(3,4)]
  i<-1
  for (x in 1:nrow(df)){
    for (y in 1:df$Changes[x]){
      mylist[i] <- df$groupMetric[x]
      i <- i + 1
    }
  }
  ggpareto(mylist, project, "Group Metrics")
}
```


### RQ4: 

Sair um pouco de predição e tentar analisar o histórico do software, ou seja, seu comportamente ao longo do tempo. Não somente analisar a efeciência (fp,tp,etc), mas também analisar através de gráficos a quantidade de pontos acima da mediana das time series, desvio padrão, etc.  Vai ser necessário melhorar o script para gerar tais resultados.
